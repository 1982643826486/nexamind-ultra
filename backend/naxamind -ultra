Estrutura de pastas e arquivos
pgsql
Copiar
Editar
nexamind-ultra/
├── backend/
│   ├── app/
│   │   ├── __init__.py
│   │   ├── main.py
│   │   ├── auth.py
│   │   ├── models.py
│   │   ├── schemas.py
│   │   ├── crud.py
│   │   ├── tasks.py
│   │   ├── utils.py
│   │   ├── llm.py
│   │   ├── plugins.py
│   │   └── database.py
│   ├── celery_worker.py
│   ├── requirements.txt
│   └── Dockerfile
├── frontend/
│   ├── src/
│   │   ├── App.js
│   │   ├── components/
│   │   ├── services/
│   │   └── index.js
│   ├── package.json
│   └── Dockerfile
├── docker-compose.yml
└── README.md
Backend/app/main.py
python
Copiar
Editar
from fastapi import FastAPI, Depends, HTTPException, BackgroundTasks
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.orm import Session
from app import models, schemas, crud, auth, llm, tasks, database

app = FastAPI()
database.Base.metadata.create_all(bind=database.engine)

def get_db():
    db = database.SessionLocal()
    try:
        yield db
    finally:
        db.close()

@app.post("/token", response_model=schemas.Token)
def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db)):
    user = auth.authenticate_user(db, form_data.username, form_data.password)
    if not user:
        raise HTTPException(status_code=401, detail="Usuário ou senha inválidos")
    access_token = auth.create_access_token(data={"sub": user.username})
    return {"access_token": access_token, "token_type": "bearer"}

@app.post("/chat/", response_model=schemas.ChatResponse)
async def chat_endpoint(request: schemas.ChatRequest, background_tasks: BackgroundTasks, 
                        current_user: schemas.User = Depends(auth.get_current_user), 
                        db: Session = Depends(get_db)):
    crud.create_message(db, current_user.id, "user", request.message)
    task = tasks.process_message_task.delay(current_user.id, request.message)
    return {"task_id": task.id, "status": "processing"}

@app.get("/chat/result/{task_id}", response_model=schemas.ChatResult)
def get_result(task_id: str, current_user: schemas.User = Depends(auth.get_current_user), db: Session = Depends(get_db)):
    result = tasks.get_task_result(task_id)
    if not result:
        raise HTTPException(status_code=404, detail="Resultado não disponível ainda")
    crud.create_message(db, current_user.id, "assistant", result)
    return {"task_id": task_id, "response": result}
Backend/app/auth.py
python
Copiar
Editar
from datetime import datetime, timedelta
from jose import JWTError, jwt
from passlib.context import CryptContext
from fastapi import Depends, HTTPException
from fastapi.security import OAuth2PasswordBearer
from sqlalchemy.orm import Session
from app import crud, schemas, database

SECRET_KEY = "SUA_CHAVE_SECRETA_AQUI"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 60

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password):
    return pwd_context.hash(password)

def authenticate_user(db: Session, username: str, password: str):
    user = crud.get_user_by_username(db, username)
    if not user:
        return False
    if not verify_password(password, user.hashed_password):
        return False
    return user

def create_access_token(data: dict, expires_delta: timedelta = None):
    to_encode = data.copy()
    expire = datetime.utcnow() + (expires_delta or timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES))
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

def get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(database.SessionLocal)):
    credentials_exception = HTTPException(
        status_code=401,
        detail="Não foi possível validar credenciais",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception
    user = crud.get_user_by_username(db, username)
    if user is None:
        raise credentials_exception
    return user
Backend/app/llm.py
python
Copiar
Editar
import openai
import os

openai.api_key = os.getenv("OPENAI_API_KEY")

def generate_response(prompt, context=None, model="gpt-4o-mini", max_tokens=600, temperature=0.7):
    messages = [{"role": "system", "content": "Você é NexaMind, um assistente inteligente."}]
    if context:
        messages.extend(context)
    messages.append({"role": "user", "content": prompt})
    response = openai.ChatCompletion.create(
        model=model,
        messages=messages,
        max_tokens=max_tokens,
        temperature=temperature
    )
    return response.choices[0].message['content'].strip()
Backend/app/tasks.py
python
Copiar
Editar
from celery import Celery
from app.llm import generate_response
from app.crud import get_conversation_context

celery_app = Celery("worker", broker="redis://localhost:6379/0", backend="redis://localhost:6379/0")

@celery_app.task(bind=True)
def process_message_task(self, user_id, message):
    context = get_conversation_context(user_id)
    response = generate_response(message, context)
    return response

def get_task_result(task_id):
    result = celery_app.AsyncResult(task_id)
    if result.ready():
        return result.get()
    return None
Frontend/src/App.js
jsx
Copiar
Editar
import React, { useState } from "react";
import axios from "axios";

function App() {
  const [token, setToken] = useState("");
  const [username, setUsername] = useState("");
  const [password, setPassword] = useState("");
  const [message, setMessage] = useState("");
  const [chatLog, setChatLog] = useState([]);
  const [taskId, setTaskId] = useState(null);
  const [response, setResponse] = useState("");

  const login = async () => {
    try {
      const res = await axios.post("/token", new URLSearchParams({
        username,
        password,
      }));
      setToken(res.data.access_token);
    } catch (e) {
      alert("Falha no login");
    }
  };

  const sendMessage = async () => {
    if (!token) return alert("Faça login primeiro");
    const res = await axios.post("/chat/", { message }, {
      headers: { Authorization: `Bearer ${token}` }
    });
    setTaskId(res.data.task_id);
  };

  const fetchResult = async () => {
    if (!taskId) return;
    const res = await axios.get(`/chat/result/${taskId}`, {
      headers: { Authorization: `Bearer ${token}` }
    });
    if (res.data.response) {
      setChatLog([...chatLog, { sender: "Você", text: message }, { sender: "NexaMind", text: res.data.response }]);
      setResponse(res.data.response);
      setTaskId(null);
      setMessage("");
    }
  };

  React.useEffect(() => {
    if (taskId) {
      const interval = setInterval(fetchResult, 2000);
      return () => clearInterval(interval);
    }
  }, [taskId]);

  return (
    <div>
      {!token ? (
        <div>
          <h2>Login NexaMind</h2>
          <input placeholder="Usuário" value={username} onChange={e => setUsername(e.target.value)} />
          <input type="password" placeholder="Senha" value={password} onChange={e => setPassword(e.target.value)} />
          <button onClick={login}>Entrar</button>
        </div>
      ) : (
        <div>
          <h2>Chat NexaMind</h2>
          <div>
            {chatLog.map((msg, i) => (
              <p key={i}><b>{msg.sender}:</b> {msg.text}</p>
            ))}
          </div>
          <textarea value={message} onChange={e => setMessage(e.target.value)} />
          <button onClick={sendMessage}>Enviar</button>
        </div>
      )}
    </div>
  );
}

export default App;
Arquivo backend/requirements.txt
css
Copiar
Editar
fastapi
uvicorn
sqlalchemy
python-jose
passlib[bcrypt]
openai
celery
redis
backend/Dockerfile
Dockerfile
Copiar
Editar
FROM python:3.10-slim

WORKDIR /app/backend

COPY ./app /app/backend/app
COPY requirements.txt .

RUN pip install --no-cache-dir -r requirements.txt

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
frontend/package.json
json
Copiar
Editar
{
  "name": "nexamind-frontend",
  "version": "1.0.0",
  "private": true,
  "dependencies": {
    "react": "^18.0.0",
    "react-dom": "^18.0.0",
    "axios": "^1.4.0"
  },
  "scripts": {
    "start": "react-scripts start"
  }
}
frontend/Dockerfile
Dockerfile
Copiar
Editar
FROM node:18-alpine

WORKDIR /app/frontend

COPY ./src ./src
COPY package.json .

RUN npm install

CMD ["npm", "start"]
docker-compose.yml
yaml
Copiar
Editar
version: "3.8"

services:
  backend:
    build:
      context: ./backend
    ports:
      - "8000:8000"
    environment:
      - OPENAI_API_KEY=${OPENAI_API_KEY}
    depends_on:
      - redis
  frontend:
    build:
      context: ./frontend
    ports:
      - "3000:3000"
    depends_on:
      - backend
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
